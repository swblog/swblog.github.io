# 权限

## 普通权限

文件有三种权限。

- r，读权限，用八进制的4或者二进制的100表示
- w，写权限，用八进制的2或者二进制的010表示
- x，执行权限，用八进制的1或者二进制的001表示

文件权限的含义。

- r：文件可以打开，读取内容。
- w：文件可以编辑和修改。是否可以改名和删除，由目录属性决定。
- x：文件可以被当作程序执行，前提是“读权限”必须也打开。

目录权限的含义。

- r：列出目录内容。
- w：允许目录内新建、删除、改名文件
- x：允许进入该目录（即`cd directory`），实质是获取目录内每个文件的详细信息

如果没有目录上的执行权限，则无法访问该目录内的文件系统对象。如果没有目录上的读权限，则无法在目录列表中查看该目录内的文件系统对象，但只要您知道该对象在磁盘上的完整路径，就可以访问这些对象。

这三种权限可以有8种组合。

- `---` 二进制的000，八进制的0
- `--x` 二进制的001，八进制的1
- `-w-` 二进制的010，八进制的2
- `-wx` 二进制的011，八进制的3
- `r--` 二进制的100，八进制的4
- `r-x` 二进制的101，八进制的5
- `rw-` 二进制的110，八进制的6
- `rwx` 二进制的111，八进制的7

每个文件或者目录有三种使用对象。

- 文件的所有者
- 文件所在的组
- 其他用户

每种对象都有上面三种权限，因此通常用`rwxrwxrwx`这种形式，表示这三种使用对象的权限，写成八进制就是`777`。

## 特殊权限

`/etc/passwd`文件，它无法由普通用户直接更改，因为只有 root 用户能启用写权限。但是，在需要更改其密码时，普通用户需要能够以某种方式修改 /etc/passwd。所以，如果用户无法修改此文件，如何实现此目的？

Linux 权限模型有两种特殊的访问模式，称为 suid（设置用户 id）和 sgid（设置组 id）。一个可执行程序设置了 suid 访问模式时，它运行起来就像是由文件的所有者启动的一样，而不是由真正启动它的用户启动的。

类似地，在设置 sgid 访问模式后，该程序运行起来就像启动的用户属于该文件的组，而不是他自己的组。可单独或同时设置两种访问模式。

```bash
$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 30768 Feb 22  2012 /usr/bin/passwd
```

上面代码中，`passwd`可执行程序由`root`所有。但是，用户的权限三元组中的 x 被 s 替代。这表明对于这个特定的程序，设置了 suid 和可执行位。所以当 passwd 运行时，它执行起来就像具有完整的超级用户访问权的 root 用户启动了它，而不是运行它的用户启动 它。因为 passwd 使用 root 访问权运行，所以它可以修改 /etc/passwd。

suid 和 sgid 位占用了用户和组的 x 位。如果该文件是可执行的，suid 或 sgid 位（如果已设置）将显示为小写的 s。否则，它们显示为大写的 S。

尽管 suid 和 sgid 使用起来很方便，甚至在许多情况下必不可少，但是，如果不在当地使用这些访问模式，可能破坏系统的安全性。您拥有尽可能少的 suid 程序。passwd 命令是为数不多的必须 为 suid 的程序之一。

suid 和 sgid 位使用字母 s 以符号方式设置和重新设置。例如，u+s 设置 suid 访问模式，g-s 删除 sgid 模式。在八进制格式中，suid 在第一个（高阶）数中具有值 4，而 sgid 具有值 2。

当一个目录启用了 sgid 模式时，其中创建的任何文件或目录都将继承该目录的组 ID。这对一组参与同一个项目的人使用的目录树特别有用。

Linux系统提供几个特殊权限。

setuid 位（八进制4000)。当应用到一个可执行文件时，它把有效用户 ID 从真正的用户（实际运行程序的用户）设置成程序所有者的 ID。这种操作通常会应用到 一些由超级用户所拥有的程序。当一个普通用户运行一个程序，这个程序由根用户(root) 所有，并且设置了 setuid 位，这个程序运行时具有超级用户的特权，这样程序就可以 访问普通用户禁止访问的文件和目录。很明显，因为这会引起安全方面的问题，所有可以 设置 setuid 位的程序个数，必须控制在绝对小的范围内。

setgid 位（八进制2000），这个相似于 setuid 位，把有效用户组 ID 从真正的用户组 ID 更改为文件所有者的组 ID。如果设置了一个目录的 setgid 位，则目录中新创建的文件具有这个目录用户组的所有权，而不是文件创建者所属用户组的所有权。

对于共享目录来说，用户A创建一个文件或目录，该文件的所有者和用户组，就是用户A，其他用户可能会无法编辑。这时，设置`setgid`位就很有用处，用户B处理这个文件时，系统自动把用户B放入该文件的用户组之中。

拥有一个目录的写权限的用户可以删除该目录的文件。这对组项目而言是可以接受的，但它对全局共享的文件空间（比如 /tmp 目录）而言不太合适。

sticky 位（八进制1000）在符号上由 t 表示，在数值上由高阶八进制数中的 1 表示。这个继承于 Unix，在 Unix 中，它可能把一个可执行文件 标志为“不可交换的”。在 Linux 中，会忽略文件的 sticky 位，但是如果一个目录设置了 sticky 位， 那么它能阻止用户删除或重命名文件，除非用户是这个目录的所有者，或者是文件所有者，或是 超级用户。这个经常用来控制访问共享目录，比方说/tmp。

```bash
# 设置程序的setuid权限
$ chmod u+s program

# 设置目录的setgid权限
$ chmod g+s dir

# 设置目录的sticky权限
$ chmod +t dir
```

设置`setuid`属性的文件，权限显示为`-rwsr-xr-x`；设置`setgid`属性的目录，权限显示为`drwxrwsr-x`；设置`sticky`属性的目录，权限显示为`drwxrwxrwt`。

## 表示方法

`ls -l`会在输出结果的每一列的头部，显示一个权限字符串，一共有10个字符。

第一个字符描述对象类型。

- -	普通文件
- d	目录
- l	符号链接
- c	字符特殊设备
- b	块特殊设备
- p	FIFO
- s	套接字

接下来的 9 个字符表示 3 个组，每组 3 个字符。第一组表示文件所有者的读、写和执行权限。第二组表示文件的组的读、写和执行权限。第三组表示其他人的权限。

## lsattr

为了防止root 用户因疏忽而删除文件的情况，各种文件系统上还有其他一些属性 提供了额外的功能。其中一个是 immutable 属性。如果设置了该属性，在取消设置它之前，即使 root 用户也无法删除文件。

可以使用 lsattr 命令查看是否为一个文件或目录设置了不可变标志（或其他任何属性）。要让文件不可变，可以使用 chattr 命令和 -i 标志。

```bash
$ touch keep.me
$ chattr +i keep.me
$ lsattr keep.me
----i---------- keep.me
$ rm -f keep.me
rm: cannot remove `keep.me': Operation not permitted
$ chattr -i keep.me
$ rm -f keep.me
```

更改不可变标志需要 root 权限。

## 掩码

创建新文件时，创建进程会指定新文件应拥有的权限。通常，请求的模式为 0666，它使该文件可由任何人读和写。目录的模式默认情况下通常为 0777。但是，这种宽容性创建会受到一个 umask 值的影响，该值指定用户不想向新创建的文件或目录自动授予哪些权限。系统使用 umask 值来减少最初请求的权限。您可以使用 umask 命令查看 umask 设置。

```bash
$ umask
0002
```

umask 指定哪些权限不应授予。在 Linux 系统上，umask 默认情况下通常为 0022，这会从新文件中删除组和其他写权限。在用户拥有私有组时（就像这些示例中使用的 CentOS 系统上一样），umask 默认情况下通常为 0002，这会删除其他用户的写权限。

如果您想让您的文件更加私有，并禁止所有组或其他用户访问新创建的文件，可以使用 umask 值 0077。或者使用 umask u=rwx,g=,o= 以符号方式设置它。

使用 -S 选项，显示哪些权限被允许的形式符号性地显示 umask。

```bash
$ umask -S
u=rwx,g=rwx,o=rx
$ umask u=rwx,g=,o=
$ umask
0077
$ touch newfile
$ ls -l newfile
-rw-------. 1 ian ian 0 Aug  9 07:09 newfile
```

上面命令中，最后创新的文件，所有者没有执行权限。请记住，新创建的文件的默认权限为 0666，而且 umask 值指定其中哪些位应删除（屏蔽掉）。所以如果您想要执行权限，必须将它显式添加到文件中。

## chgrp

要创建一个文件的组，可以使用 chgrp 命令和一个组名及一个或多个文件名。如果愿意的话，还可以使用组成员。普通用户必须拥有该文件，而且还是该文件组更改的目标组的成员。root 用户可以将文件更改到任何组。

chgrp 提供了一个 -R 选项，允许以递归方式向所有选择的文件和子目录应用更改。

```bash
$ touch file{1,2}
$ ls -l file*
-rw-rw-r--. 1 ian ian 0 Aug  9 07:16 file1
-rw-rw-r--. 1 ian ian 0 Aug  9 07:16 file2
$ chgrp development file1
$ chgrp 1002 file2
$ ls -l file*
-rw-rw-r--. 1 ian development 0 Aug  9 07:16 file1
-rw-rw-r--. 1 ian development 0 Aug  9 07:16 file2
```

## chown

root 用户可以使用`chown`命令更改文件的所有权。在最简单的形式中，它的语法类似于 chgrp 命令，但使用了用户名或数值 ID 来代替组名称或 ID。此外，您还可以更改该文件的组，只需在用户名或 ID 后添加一个冒号和一个组名称或 ID。如果只提供了一个冒号，那么将使用用户的默认组。自然地，`-R`选项将递归地应用更改。

```bash
$ touch file4
$ su -
Password:
$ ls -l ~ian/file4
-rw-rw-r--. 1 ian ian 0 Aug  9 07:27 /home/ian/file4
$ chown greg ~ian/file4
$ ls -l ~ian/file4
-rw-rw-r--. 1 greg ian 0 Aug  9 07:27 /home/ian/file4
$ chown jenni:mary ~ian/file4
$ ls -l ~ian/file4
-rw-rw-r--. 1 jenni mary 0 Aug  9 07:27 /home/ian/file4
$ chown :jenni ~ian/file4
$ ls -l ~ian/file4
-rw-rw-r--. 1 jenni jenni 0 Aug  9 07:27 /home/ian/file4
```

## newgrp

newgrp 命令临时将您的主要组更改为您所属的另一个组。这将创建一个新的 shell，而且在退出该 shell 时，以前的组将恢复原状，

```bash
$ groups
ian development editor
$ newgrp development
$ groups
development ian editor
$ touch file3
$ ls -l file3
-rw-r--r--. 1 ian development 0 Aug  9 07:21 file3
$ exit
exit
$ groups
ian development editor
```
